#include <TinyGPS++.h>
#include <LiquidCrystal.h>
#include <SoftwareSerial.h>
const int rs = 8, en = 9, d4 = 10, d5 = 11, d6 = 12, d7 = 13;
LiquidCrystal lcd(rs, en, d4, d5, d6, d7);
SoftwareSerial uart(2, 3);
int scale = 5 ;
int relay = 4;
#define TRIG_PIN 6
#define ECHO_PIN 7
long duration;
float distance;
TinyGPSPlus gps;
String LAT, LON;
String msg;




void setup()
{
  Serial.begin(9600);
  uart.begin(9600);
  pinMode(relay, OUTPUT);
  pinMode(TRIG_PIN, OUTPUT); // Set the TRIG pin as output
  pinMode(ECHO_PIN, INPUT);  // Set the ECHO pin as input



  lcd.begin(16, 2);
  lcd.clear();
  lcd.setCursor(0, 0);
  lcd.print("Object detection ");
  lcd.setCursor(0, 1);
  lcd.print("avoid accidents");
  delay(2000);
  lcd.clear();
  lcd.setCursor(0, 0);
  lcd.print("improve Driver ");
  lcd.setCursor(0, 1);
  lcd.print("Assistance");
  delay(2000);


}
void loop()
{
  smartDelay(2000);

  digitalWrite(TRIG_PIN, LOW);
  delayMicroseconds(2);
  digitalWrite(TRIG_PIN, HIGH);
  delayMicroseconds(10);
  digitalWrite(TRIG_PIN, LOW);

  // Read the ECHO pin, and calculate the distance
  duration = pulseIn(ECHO_PIN, HIGH); // Measure time in microseconds
  distance = (duration * 0.034) / 2;  // Convert to centimeters

  // Print the distance to the Serial Monitor
//  Serial.print("Distance: ");
//  Serial.print(distance);
//  Serial.println(" cm");
  lcd.clear();
  lcd.setCursor(0, 0);
  lcd.print("distance ");
  lcd.print(distance);
  delay(2000); // Delay between readings
//  Serial.println(String("a"));
  if (distance < 30)
  {
  Serial.println(String("1"));
    lcd.clear();
    lcd.setCursor(0, 0);
    lcd.print("Obstacle detected");
    digitalWrite(relay, LOW );
    delay(5000);

  }

  else {
    digitalWrite(relay, HIGH );
    delay(1000);
  }

  int x = analogRead(A0);
  int y = analogRead(A1);
  int z = analogRead(A2);

  float scaledX, scaledY, scaledZ;
  scaledX = mapf(x, 0, 675, -scale, scale);
  scaledY = mapf(y, 0, 675, -scale, scale);
  scaledZ = mapf(z, 0, 675, -scale, scale);

  //   Print out raw X,Y,Z accelerometer readings
//  Serial.print("X: "); Serial.println(x);
//  Serial.print("Y: "); Serial.println(y);
//  Serial.print("Z: "); Serial.println(z);
//  Serial.println();

  //  // Print out scaled X,Y,Z accelerometer readings
  //  Serial.print("X: "); Serial.print(scaledX); Serial.print(" g\t");
  //  Serial.print("Y: "); Serial.print(scaledY); Serial.print(" g\t");
  //  Serial.print("Z: "); Serial.print(scaledZ); Serial.print(" g\t");
  //  Serial.println();


  delay(1000);

  if (x < 360 || y < 260  )
  {
//    Serial.print("\tfront\t");
    lcd.clear();
    lcd.setCursor(0, 0);
    lcd.print("Accident detected");
    delay(1000);

    digitalWrite(relay, LOW);
    msg = "Accident detected";
    SendMessage();
    delay(1000);
  }
    else {
    digitalWrite(relay, HIGH );
    delay(1000);
    }


  String LAT = String(gps.location.lat(), 6);
  String LON = String(gps.location.lng(), 6);
  lcd.clear();
  lcd.setCursor(0, 0);
  lcd.print("lat: ");
  lcd.print(LAT);
  lcd.setCursor(0, 1);
  lcd.print("lng: ");
  lcd.print(LON);
  delay(1000);



}

float mapf(float x, float in_min, float in_max, float out_min, float out_max)
{
  return (x - in_min) * (out_max - out_min) / (in_max - in_min) + out_min;
}





void SendMessage()
{

  uart.println("AT+CMGF=1\r");
  delay(2000);
  uart.println("AT+CMGS=\"+919515107259\"\r");
  // Replace x with mobile number
  delay(2000);
  uart.print(msg);
  uart.println("http://www.google.com/maps/place/"  + String(gps.location.lat(), 6) + " ," + String(gps.location.lng(), 6));
  uart.write(26);
  lcd.clear();
  lcd.setCursor(0, 0);
  lcd.print("Message sent");

  delay(2000);
}
static void smartDelay(unsigned long ms)
{
  unsigned long start = millis();
  do
  {
    while (uart.available())  /* Encode data read from GPS while data is available on serial port */
      gps.encode(uart.read());
    /* Encode basically is used to parse the string received by the GPS and to store it in a buffer so that information can be extracted from it */
  } while (millis() - start < ms);
}